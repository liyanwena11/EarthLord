import SwiftUI
import CoreLocation
import UIKit
import Supabase

@MainActor
class EarthLordEngine: NSObject, ObservableObject, CLLocationManagerDelegate {
    static let shared = EarthLordEngine()
    private let locationManager = CLLocationManager()
    private let geocoder = CLGeocoder()
    private var survivorTimer: Timer?
    private var respawnTimer: Timer?

    // MARK: - åŸºç¡€çŠ¶æ€
    @Published var userLocation: CLLocation?
    @Published var nearbyPOIs: [POIModel] = []
    @Published var claimedTerritories: [TerritoryModel] = []
    @Published var nearbyPlayerCount: Int = 0
    @Published var activePOI: POIModel?
    @Published var showProximityAlert: Bool = false
    @Published var isExploring: Bool = false
    @Published var exploringStatusText: String = ""

    // MARK: - é‡‡æ ·åœˆåœ°çŠ¶æ€
    @Published var isTracking: Bool = false              // æ˜¯å¦æ­£åœ¨åœˆåœ°
    @Published var pathPoints: [CLLocation] = []         // é‡‡æ ·è½¨è¿¹ç‚¹
    @Published var trackingDistance: Double = 0           // å·²è¡Œèµ°è·ç¦»ï¼ˆç±³ï¼‰
    @Published var estimatedArea: Double = 0             // é¢„ä¼°é¢ç§¯ï¼ˆã¡ï¼‰
    @Published var trackingStatusText: String = ""       // é¡¶éƒ¨çŠ¶æ€æ–‡å­—

    /// åŠ¨æ€é‡‡æ ·ç‚¹éœ€æ±‚ï¼šè´Ÿé‡ > 80kg æ—¶ä» 5 å¢åŠ åˆ° 8
    var requiredSamplingPoints: Int {
        let weight = ExplorationManager.shared.totalWeight
        if weight > 80 {
            return 8
        }
        return GameConfig.SAMPLING_MIN_POINTS
    }

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 5.0
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
        LogDebug("ğŸš€ [Engine] EarthLordEngine åˆå§‹åŒ–å®Œæˆ")
        LogDebug("ğŸ“ [GPS] å®šä½æœåŠ¡å·²å¯åŠ¨")
        survivorTimer = Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { [weak self] _ in
            Task { @MainActor in self?.updateSurvivorCount() }
        }
        respawnTimer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { [weak self] _ in
            Task { @MainActor in self?.checkRespawns() }
        }
    }

    deinit {
        survivorTimer?.invalidate()
        respawnTimer?.invalidate()
    }

    // MARK: - å¹¸å­˜è€…æ‰«æ

    @MainActor
    private func updateSurvivorCount() {
        self.isExploring = true
        self.exploringStatusText = "æ­£åœ¨æ‰«æå‘¨è¾¹ä¿¡å·..."
        self.nearbyPlayerCount = Int.random(in: 1...30)
        LogDebug("ğŸ“¡ [æ¢ç´¢] é›·è¾¾æ‰«æä¸­... æ£€æµ‹åˆ° \(nearbyPlayerCount) åå¹¸å­˜è€…")
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.isExploring = false
            self?.exploringStatusText = ""
        }
    }

    // MARK: - POI åˆ·æ–°

    @MainActor
    private func checkRespawns() {
        var refreshed = 0
        for index in nearbyPOIs.indices {
            if nearbyPOIs[index].isScavenged && nearbyPOIs[index].canScavengeAgain {
                nearbyPOIs[index].isScavenged = false
                nearbyPOIs[index].lastScavengedAt = nil
                refreshed += 1
            }
        }
        if refreshed > 0 {
            LogDebug("ğŸ”„ [åˆ·æ–°] \(refreshed) ä¸ª POI å·²åˆ·æ–°")
        }
    }

    // MARK: - ========== é‡‡æ ·è¡Œèµ°åœˆåœ° ==========

    /// å¼€å§‹åœˆåœ°ï¼šæ¸…ç©ºæ—§è·¯å¾„ï¼Œè¿›å…¥åœˆåœ°æ¨¡å¼
    @MainActor
    func startTracking() {
        pathPoints.removeAll()
        trackingDistance = 0
        estimatedArea = 0
        isTracking = true
        trackingStatusText = "å¼€å§‹åœˆåœ°ï¼Œè¯·è¡Œèµ°åˆ›å»ºé¢†åœ°è¾¹ç•Œ..."

        UIImpactFeedbackGenerator(style: .medium).impactOccurred()

        LogDebug("ğŸš© [åœˆåœ°] ========== å¼€å§‹åœˆåœ° ==========")
        LogDebug("ğŸ¯ [åœˆåœ°] é‡‡æ ·ç‚¹éœ€æ±‚: \(requiredSamplingPoints) ä¸ªç‚¹ (å½“å‰è´Ÿé‡: \(String(format: "%.1f", ExplorationManager.shared.totalWeight))kg)")
        LogDebug("ğŸ“ [åœˆåœ°] è·ç¦»è¿‡æ»¤: â‰¥ \(GameConfig.SAMPLING_MIN_DISTANCE)m")
        LogWarning("âš ï¸ [åœˆåœ°] GPS ç²¾åº¦è¿‡æ»¤: < 100m")
        // ç«‹å³è®°å½•ç¬¬ä¸€ä¸ªç‚¹
        if let loc = userLocation {
            pathPoints.append(loc)
            LogInfo("ğŸ“ [åœˆåœ°] âœ… èµ·ç‚¹1å·²è®°å½•: (\(String(format: "%.5f", loc.coordinate.latitude)), \(String(format: "%.5f", loc.coordinate.longitude))), ç²¾åº¦: \(String(format: "%.1f", loc.horizontalAccuracy))m")
        } else {
            LogError("âŒ [åœˆåœ°] âš ï¸ è­¦å‘Šï¼šæ— æ³•è·å–å½“å‰ä½ç½®ï¼")
        }
    }

    /// åœæ­¢åœˆåœ°ï¼ˆå–æ¶ˆï¼‰
    @MainActor
    func stopTracking() {
        isTracking = false
        trackingStatusText = ""
        pathPoints.removeAll()
        trackingDistance = 0
        estimatedArea = 0
        LogDebug("ğŸ›‘ [åœˆåœ°] å·²å–æ¶ˆåœˆåœ°")
    }

    /// GPS å›è°ƒä¸­è°ƒç”¨ï¼šåœˆåœ°é€»è¾‘ï¼ˆç§»é™¤è‡ªåŠ¨å®Œæˆï¼‰
    @MainActor
    private func handleTrackingSample(_ location: CLLocation) {
        guard isTracking else { return }

        LogDebug("ğŸ“ [GPSå›è°ƒ] æ”¶åˆ°ä½ç½®æ›´æ–°ï¼Œç²¾åº¦: \(String(format: "%.1f", location.horizontalAccuracy))m")
        // ç²¾åº¦è¿‡æ»¤ï¼ˆæ”¾ï¿½ï¿½ï¿½åˆ°100mï¼Œé€‚åº”çœŸæœºç¯å¢ƒï¼‰
        if location.horizontalAccuracy > 100 {
            LogWarning("âš ï¸ [åœˆåœ°] ç²¾åº¦å·® \(String(format: "%.0f", location.horizontalAccuracy))mï¼Œè·³è¿‡")
            return
        }

        // è·ç¦»è¿‡æ»¤ï¼šè·ä¸Šä¸€ä¸ªç‚¹ â‰¥ 10m æ‰è®°å½•
        if let lastPoint = pathPoints.last {
            let dist = location.distance(from: lastPoint)
            LogDebug("ğŸ“ [åœˆåœ°] è·ä¸Šä¸€ä¸ªç‚¹: \(String(format: "%.1f", dist))m (éœ€è¦ â‰¥ \(GameConfig.SAMPLING_MIN_DISTANCE)m)")
            if dist < GameConfig.SAMPLING_MIN_DISTANCE {
                return
            }

            // è·³ç‚¹è¿‡æ»¤ï¼šå•æ­¥ > 200m è§†ä¸ºå¼‚å¸¸
            if dist > 200 {
                LogWarning("âš ï¸ [åœˆåœ°] è·³ç‚¹ \(String(format: "%.0f", dist))mï¼Œä¸¢å¼ƒ")
                return
            }

            trackingDistance += dist
        }

        pathPoints.append(location)
        estimatedArea = calculatePolygonArea(pathPoints)

        let pointCount = pathPoints.count
        trackingStatusText = "åœˆåœ°ä¸­ Â· è·ç¦» \(Int(trackingDistance))m Â· é¢ç§¯ \(Int(estimatedArea))ã¡"

        LogInfo("âœ… [åœˆåœ°] ç¬¬\(pointCount)ç‚¹å·²è®°å½•ï¼ç§»åŠ¨è·ç¦»: \(String(format: "%.1f", trackingDistance))m")
        LogDebug("ğŸ“ [é¢ç§¯] å½“å‰é—­åˆé¢ç§¯: \(String(format: "%.1f", estimatedArea))ã¡")
        // é‡‡æ ·ç‚¹è¾¾åˆ°è¦æ±‚åè‡ªåŠ¨å®Œæˆåœˆåœ°
        if pathPoints.count >= requiredSamplingPoints {
            LogDebug("ğŸ‰ [åœˆåœ°] é‡‡æ ·ç‚¹è¾¾æ ‡ \(pathPoints.count)/\(requiredSamplingPoints)ï¼Œè‡ªåŠ¨å®Œæˆåœˆåœ°")
            UINotificationFeedbackGenerator().notificationOccurred(.success)
            finishTracking()
        }
    }

    /// éªŒè¯è½¨è¿¹æ˜¯å¦åˆç†
    @MainActor
    private func validateTrajectory() -> (isValid: Bool, errorMessage: String?) {
        guard pathPoints.count >= 3 else {
            return (false, "é‡‡æ ·ç‚¹ä¸è¶³ï¼Œè‡³å°‘éœ€è¦3ä¸ªç‚¹ï¼ˆå½“å‰: \(pathPoints.count)ä¸ªï¼‰")
        }

        // æ£€æŸ¥èµ·ç‚¹ç»ˆç‚¹è·ç¦»ï¼ˆåº”è¯¥æ¥è¿‘ï¼Œå½¢æˆé—­ç¯ï¼‰
        let start = pathPoints.first!
        let end = pathPoints.last!
        let closureDistance = start.distance(from: end)

        if closureDistance > 100 {
            LogWarning("âš ï¸ [åœˆåœ°éªŒè¯] è½¨è¿¹æœªé—­åˆï¼Œèµ·ç‚¹ç»ˆç‚¹è·ç¦»: \(closureDistance)m")
            return (false, "è½¨è¿¹æœªé—­åˆï¼Œèµ·ç‚¹ç»ˆç‚¹è·ç¦» \(Int(closureDistance))mï¼Œè¯·èµ°å›èµ·ç‚¹é™„è¿‘")
        }

        // æ£€æŸ¥é¢ç§¯åˆç†æ€§
        let area = calculatePolygonArea(pathPoints)
        if area < 100 {
            LogWarning("âš ï¸ [åœˆåœ°éªŒè¯] é¢ç§¯è¿‡å°: \(area)ã¡")
            return (false, "é¢ç§¯è¿‡å° \(Int(area))ã¡ï¼Œæœ€å°éœ€è¦100ã¡")
        }

        if area > 10_000_000 {
            LogWarning("âš ï¸ [åœˆåœ°éªŒè¯] é¢ç§¯å¼‚å¸¸è¿‡å¤§: \(area)ã¡")
            return (false, "é¢ç§¯å¼‚å¸¸è¿‡å¤§ \(Int(area))ã¡ï¼Œå¯èƒ½å­˜åœ¨GPSæ¼‚ç§»")
        }

        // æ£€æŸ¥è½¨è¿¹è‡ªç›¸äº¤
        if hasSelfIntersection() {
            LogWarning("âš ï¸ [åœˆåœ°éªŒè¯] è½¨è¿¹å­˜åœ¨è‡ªç›¸äº¤")
            return (false, "è½¨è¿¹å­˜åœ¨è‡ªç›¸äº¤ï¼Œè¯·é‡æ–°è§„åˆ’è·¯å¾„")
        }

        LogInfo("âœ… [åœˆåœ°éªŒè¯] éªŒè¯é€šè¿‡ - é‡‡æ ·ç‚¹: \(pathPoints.count), é¢ç§¯: \(Int(area))ã¡, é—­åˆè·ç¦»: \(Int(closureDistance))m")
        return (true, nil)
    }

    /// æ£€æŸ¥è½¨è¿¹æ˜¯å¦è‡ªç›¸äº¤
    private func hasSelfIntersection() -> Bool {
        guard pathPoints.count >= 4 else { return false }

        // ç®€åŒ–æ£€æŸ¥ï¼šæ£€æŸ¥ä»»æ„ä¸¤æ¡è¾¹ï¼ˆä¸ç›¸é‚»ï¼‰æ˜¯å¦ç›¸äº¤
        let coords = pathPoints.map { $0.coordinate }

        for i in 0..<(coords.count - 1) {
            for j in (i + 2)..<(coords.count - 1) {
                // è·³è¿‡è¿æ¥åˆ°èµ·ç‚¹çš„è¾¹ï¼ˆæœ€åä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹è¿æ¥æ˜¯æ­£å¸¸çš„é—­åˆï¼‰
                if j == coords.count - 2 && i == 0 {
                    continue
                }

                if doLinesIntersect(
                    coords[i], coords[i + 1],
                    coords[j], coords[j + 1]
                ) {
                    return true
                }
            }
        }
        return false
    }

    /// åˆ¤æ–­ä¸¤æ¡çº¿æ®µæ˜¯å¦ç›¸äº¤
    private func doLinesIntersect(_ p1: CLLocationCoordinate2D, _ p2: CLLocationCoordinate2D,
                                  _ p3: CLLocationCoordinate2D, _ p4: CLLocationCoordinate2D) -> Bool {
        // ä½¿ç”¨å‘é‡å‰ç§¯åˆ¤æ–­çº¿æ®µç›¸äº¤
        func crossProduct(_ a: CLLocationCoordinate2D, _ b: CLLocationCoordinate2D, _ c: CLLocationCoordinate2D) -> Double {
            return (b.longitude - a.longitude) * (c.latitude - a.latitude) -
                   (b.latitude - a.latitude) * (c.longitude - a.longitude)
        }

        let cp1 = crossProduct(p3, p4, p1)
        let cp2 = crossProduct(p3, p4, p2)
        let cp3 = crossProduct(p1, p2, p3)
        let cp4 = crossProduct(p1, p2, p4)

        // æ£€æŸ¥æ˜¯å¦è·¨ç«‹
        if ((cp1 > 0 && cp2 < 0) || (cp1 < 0 && cp2 > 0)) &&
           ((cp3 > 0 && cp4 < 0) || (cp3 < 0 && cp4 > 0)) {
            return true
        }

        // æ£€æŸ¥ç«¯ç‚¹é‡åˆ
        if cp1 == 0 && isPointOnLine(p1, p3, p4) { return true }
        if cp2 == 0 && isPointOnLine(p2, p3, p4) { return true }
        if cp3 == 0 && isPointOnLine(p3, p1, p2) { return true }
        if cp4 == 0 && isPointOnLine(p4, p1, p2) { return true }

        return false
    }

    /// åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨çº¿æ®µä¸Š
    private func isPointOnLine(_ p: CLLocationCoordinate2D, _ a: CLLocationCoordinate2D, _ b: CLLocationCoordinate2D) -> Bool {
        let cross = (p.longitude - a.longitude) * (b.latitude - a.latitude) -
                    (p.latitude - a.latitude) * (b.longitude - a.longitude)
        if abs(cross) > 1e-10 { return false }

        let dot = (p.longitude - a.longitude) * (b.longitude - a.longitude) +
                  (p.latitude - a.latitude) * (b.latitude - a.latitude)
        if dot < 0 { return false }

        let squaredLength = (b.longitude - a.longitude) * (b.longitude - a.longitude) +
                            (b.latitude - a.latitude) * (b.latitude - a.latitude)
        return dot <= squaredLength
    }

    /// å®Œæˆåœˆåœ°ï¼šç”Ÿæˆé¢†åœ°
    @MainActor
    private func finishTracking() {
        guard pathPoints.count >= 3 else { return }

        // éªŒè¯è½¨è¿¹
        let validation = validateTrajectory()
        guard validation.isValid else {
            LogError("âŒ [åœˆåœ°] éªŒè¯å¤±è´¥: \(validation.errorMessage ?? "æœªçŸ¥é”™è¯¯")")
            trackingStatusText = "âš ï¸ \(validation.errorMessage ?? "éªŒè¯å¤±è´¥")"
            UINotificationFeedbackGenerator().notificationOccurred(.error)
            // ä¸è‡ªåŠ¨å®Œæˆï¼Œè®©ç”¨æˆ·ç»§ç»­é‡‡æ ·æˆ–æ‰‹åŠ¨å–æ¶ˆ
            return
        }

        let area = calculatePolygonArea(pathPoints)

        // è®¡ç®—ä¸­å¿ƒç‚¹
        let centerLat = pathPoints.map { $0.coordinate.latitude }.reduce(0, +) / Double(pathPoints.count)
        let centerLon = pathPoints.map { $0.coordinate.longitude }.reduce(0, +) / Double(pathPoints.count)

        let newTerritory = TerritoryModel(
            id: UUID(),
            lat: centerLat,
            lon: centerLon,
            claimedAt: Date(),
            name: "é¢†åœ° #\(claimedTerritories.count + 1)",
            area: area,
            pointCount: pathPoints.count,
            pathLatitudes: pathPoints.map { $0.coordinate.latitude },
            pathLongitudes: pathPoints.map { $0.coordinate.longitude }
        )

        // é‡åº¦éœ‡åŠ¨åé¦ˆ
        UINotificationFeedbackGenerator().notificationOccurred(.success)
        UIImpactFeedbackGenerator(style: .heavy).impactOccurred()

        LogInfo("ğŸš© [åœˆåœ°] âœ… é¢†åœ°ç¡®è®¤ï¼é¢ç§¯: \(String(format: "%.1f", area))ã¡ï¼Œé‡‡æ ·ç‚¹: \(pathPoints.count)")
        // åœ°ç†é€†ç¼–ç è·å–è¡—é“å
        let centerLocation = CLLocation(latitude: centerLat, longitude: centerLon)
        let territoryId = newTerritory.id // æ•è·IDè€Œä¸æ˜¯æ•´ä¸ªå¯¹è±¡
        geocoder.reverseGeocodeLocation(centerLocation) { [weak self] placemarks, error in
            Task { @MainActor [weak self] in
                if let placemark = placemarks?.first {
                    let street = placemark.thoroughfare ?? placemark.name ?? placemark.subLocality ?? ""
                    let district = placemark.subLocality ?? placemark.locality ?? ""
                    let geocodedName = street.isEmpty ? district : street
                    if !geocodedName.isEmpty {
                        // æ›´æ–°é¢†åœ°åç§°
                        if let index = self?.claimedTerritories.firstIndex(where: { $0.id == territoryId }) {
                            self?.claimedTerritories[index].name = geocodedName
                            LogDebug("ğŸ·ï¸ [åœˆåœ°] é¢†åœ°å‘½åä¸º: \(geocodedName)")
                        }
                    }
                }
            }
        }

        self.claimedTerritories.append(newTerritory)

        LogDebug("ğŸ—ºï¸ [åœˆåœ°] å½“å‰æœ¬åœ°é¢†åœ°æ•°é‡: \(claimedTerritories.count)")
        LogDebug("ğŸ—ºï¸ [åœˆåœ°] æ–°é¢†åœ° pathCoordinates æ•°é‡: \(newTerritory.pathCoordinates.count)")

        // å…ˆå¿«ç…§åæ ‡ï¼Œé¿å…å¼‚æ­¥ä»»åŠ¡è¯»å–åˆ°è¢«æ¸…ç©ºåçš„ pathPoints
        let coordinates = pathPoints.map { $0.coordinate }
        let startTime = Date()

        // åœˆåœ°å®Œæˆåç«‹åˆ»æŠŠæ•°æ®åŠ å…¥é¢†åœ°åˆ—è¡¨ï¼ˆæ— éœ€ç­‰å¾…ç½‘ç»œï¼‰
        if let userId = AuthManager.shared.currentUser?.id.uuidString {
            let formatter = ISO8601DateFormatter()
            let territoryPreview = Territory(
                id: newTerritory.id.uuidString,
                userId: userId,
                name: newTerritory.name,
                path: coordinates.map { ["lat": $0.latitude, "lon": $0.longitude] },
                area: area,
                pointCount: coordinates.count,
                isActive: true,
                completedAt: formatter.string(from: Date()),
                startedAt: formatter.string(from: startTime),
                createdAt: formatter.string(from: Date()),
                level: 1,
                experience: 0,
                prosperity: 0
            )
            TerritoryManager.shared.addLocalTerritoryIfNeeded(territoryPreview)
            NotificationCenter.default.post(name: .territoryUpdated, object: nil)
        }

        // ä¸Šä¼ é¢†åœ°ä¸Šä¼ åˆ° Supabase
        Task {
            do {
                // âœ… è·å–å½“å‰ç”¨æˆ·ä¼šè¯
                let session = try await supabaseClient.auth.session

                try await TerritoryManager.shared.uploadTerritory(
                    coordinates: coordinates,
                    area: area,
                    startTime: startTime
                )
                LogInfo("ğŸš© [åœˆåœ°] é¢†åœ°ä¸Šä¼ æˆåŠŸï¼")
                // âœ… ç«‹å³åˆ·æ–°åœ°å›¾ä¸Šçš„é¢†åœŸæ˜¾ç¤º
                await MainActor.run {
                    NotificationCenter.default.post(name: .territoryUpdated, object: nil)
                }

                // âœ… æ·»åŠ åˆ°Supabaseé¢†åœŸåˆ—è¡¨ä»¥ä¾¿ç«‹å³æ˜¾ç¤º
                await MainActor.run {
                    // åˆ›å»ºä¸€ä¸ªæ–°çš„Territoryå¯¹è±¡ç”¨äºç«‹å³æ˜¾ç¤º
                    let formatter = ISO8601DateFormatter()
                    let territoryToAdd = Territory(
                        id: newTerritory.id.uuidString,
                        userId: session.user.id.uuidString,
                        name: newTerritory.name,
                        path: coordinates.map { ["lat": $0.latitude, "lon": $0.longitude] },
                        area: area,
                        pointCount: coordinates.count,
                        isActive: true,
                        completedAt: formatter.string(from: Date()),
                        startedAt: formatter.string(from: startTime),
                        createdAt: formatter.string(from: Date()),
                        level: 1,
                        experience: 0,
                        prosperity: 0
                    )
                    // é€šçŸ¥åœ°å›¾æ·»åŠ æ–°é¢†åœŸ
                    NotificationCenter.default.post(name: .territoryAdded, object: territoryToAdd)
                }
            } catch {
                LogError("ğŸš© [åœˆåœ°] é¢†åœ°ä¸Šä¼ å¤±è´¥: \(error.localizedDescription)")
            }
        }

        // é‡ç½®çŠ¶æ€
        isTracking = false
        trackingStatusText = "åœˆåœ°å®Œæˆï¼é¢ç§¯ \(Int(area))ã¡"
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) { [weak self] in
            self?.trackingStatusText = ""
        }
        pathPoints.removeAll()
        trackingDistance = 0
        estimatedArea = 0
    }

    /// å¼ºåˆ¶å®Œæˆåœˆåœ°ï¼ˆè°ƒè¯•ç”¨ / æ‰‹åŠ¨é—­åˆï¼‰
    @MainActor
    func forceFinishTracking() {
        guard isTracking else {
            LogError("âŒ [åœˆåœ°] å½“å‰æœªåœ¨åœˆåœ°çŠ¶æ€ï¼Œæ— æ³•å®Œæˆ")
            return
        }

        guard pathPoints.count >= 3 else {
            LogError("âŒ [åœˆåœ°] é‡‡æ ·ç‚¹ä¸è¶³ 3 ä¸ªï¼ˆå½“å‰: \(pathPoints.count) ä¸ªï¼‰ï¼Œæ— æ³•å®Œæˆ")
            UINotificationFeedbackGenerator().notificationOccurred(.error)
            return
        }

        LogInfo("ğŸ§ª [åœˆåœ°] âœ… å¼ºåˆ¶å®Œæˆåœˆåœ°ï¼å½“å‰é‡‡æ ·ç‚¹: \(pathPoints.count) ä¸ª")
        finishTracking()
    }

    // MARK: - å¤šè¾¹å½¢é¢ç§¯è®¡ç®—ï¼ˆShoelace å…¬å¼ + ç»çº¬åº¦â†’ç±³æ¢ç®—ï¼‰

    private func calculatePolygonArea(_ points: [CLLocation]) -> Double {
        guard points.count >= 3 else { return 0 }

        // ä»¥ç¬¬ä¸€ä¸ªç‚¹ä¸ºåŸç‚¹ï¼Œå°†ç»çº¬åº¦è½¬ä¸ºå¹³é¢ç±³åæ ‡
        let origin = points[0].coordinate
        let metersPerDegreeLat = 111320.0
        let metersPerDegreeLon = 111320.0 * cos(origin.latitude * .pi / 180)

        let xyPoints = points.map { p -> (x: Double, y: Double) in
            let x = (p.coordinate.longitude - origin.longitude) * metersPerDegreeLon
            let y = (p.coordinate.latitude - origin.latitude) * metersPerDegreeLat
            return (x, y)
        }

        // Shoelace å…¬å¼
        var area: Double = 0
        let n = xyPoints.count
        for i in 0..<n {
            let j = (i + 1) % n
            area += xyPoints[i].x * xyPoints[j].y
            area -= xyPoints[j].x * xyPoints[i].y
        }
        return abs(area) / 2.0
    }

    // MARK: - GPS ä½ç½®æ›´æ–°

    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }

        LogDebug("ğŸ›°ï¿½ï¿½ï¿½ [GPS] ä½ç½®æ›´æ–°: lat=\(String(format: "%.5f", location.coordinate.latitude)), lon=\(String(format: "%.5f", location.coordinate.longitude)), ç²¾åº¦=\(String(format: "%.1f", location.horizontalAccuracy))m")
        Task { @MainActor in
            self.userLocation = location
            self.checkProximity(location)
            self.handleTrackingSample(location)
        }
    }

    // MARK: - POI æ¥è¿‘æ£€æµ‹

    @MainActor
    private func checkProximity(_ current: CLLocation) {
        let found = nearbyPOIs.first {
            !$0.isScavenged && current.distance(from: $0.location) <= GameConfig.POI_TRIGGER_RADIUS
        }
        if let target = found {
            if activePOI?.id != target.id {
                self.activePOI = target
                self.showProximityAlert = true
                UIImpactFeedbackGenerator(style: .heavy).impactOccurred()
                LogDebug("ğŸ¯ [æœåˆ®] è¿›å…¥ POI èŒƒå›´ï¼š\(target.name)ï¼ˆ\(target.rarity.rawValue)ï¼‰")
            }
        } else {
            if showProximityAlert {
                self.showProximityAlert = false
                self.activePOI = nil
            }
        }
    }

    // MARK: - æœåˆ®

    @MainActor
    func scavenge() {
        guard let poi = activePOI else { return }
        if let index = nearbyPOIs.firstIndex(where: { $0.id == poi.id }) {
            nearbyPOIs[index].isScavenged = true
            nearbyPOIs[index].lastScavengedAt = Date()
            LogDebug("ğŸ“¦ [æœåˆ®] å·²æœåˆ® POIï¼š\(poi.name)")
        }
        self.showProximityAlert = false
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
    }

    /// æœåˆ®çŠ¶æ€
    @Published var isScavenging: Bool = false
    @Published var lastScavengeResult: [BackpackItem] = []

    /// æœåˆ®å¹¶ç”Ÿæˆæ‰è½ç‰©å“ï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼Œç”¨é¢„è®¾æ‰è½è¡¨ï¼‰
    @MainActor
    func scavengeWithLoot() -> [BackpackItem] {
        guard let poi = activePOI else { return [] }

        let backpack = ExplorationManager.shared
        if backpack.totalWeight >= backpack.maxCapacity {
            LogWarning("âš ï¸ [æœåˆ®] èƒŒåŒ…å·²æ»¡ï¼Œæ— æ³•æœåˆ®")
            return []
        }

        if let index = nearbyPOIs.firstIndex(where: { $0.id == poi.id }) {
            nearbyPOIs[index].isScavenged = true
            nearbyPOIs[index].lastScavengedAt = Date()
        }
        self.showProximityAlert = false

        let items = generateLootByRarity(poi.rarity)
        backpack.addItems(items: items)

        UINotificationFeedbackGenerator().notificationOccurred(.success)
        LogDebug("ğŸ“¦ [æœåˆ®] åœ¨ã€Œ\(poi.name)ã€(\(poi.rarity.rawValue)) è·å¾—ï¼š\(items.map { "\($0.name) x\($0.quantity)" }.joined(separator: ", "))")
        return items
    }

    /// AI æœåˆ®ï¼šè°ƒç”¨ Edge Function ç”Ÿæˆç‹¬ç‰¹ç‰©å“ï¼ˆå¼‚æ­¥ï¼‰
    @MainActor
    func scavengeWithAI() async -> [BackpackItem] {
        guard let poi = activePOI else { return [] }

        let backpack = ExplorationManager.shared
        if backpack.totalWeight >= backpack.maxCapacity {
            LogWarning("âš ï¸ [æœåˆ®] èƒŒåŒ…å·²æ»¡ï¼Œæ— æ³•æœåˆ®")
            return []
        }

        isScavenging = true

        // æ ‡è®° POI å·²æœåˆ®
        if let index = nearbyPOIs.firstIndex(where: { $0.id == poi.id }) {
            nearbyPOIs[index].isScavenged = true
            nearbyPOIs[index].lastScavengedAt = Date()
        }
        self.showProximityAlert = false

        // è°ƒç”¨ AI ç”Ÿæˆï¼ˆå†…å«é™é»˜é™çº§ï¼‰
        let items = await AIItemGenerator.shared.generateItems(for: poi)

        // å­˜å…¥èƒŒåŒ…
        backpack.addItems(items: items)

        // åŒæ­¥åˆ° Supabase user_inventory
        Task {
            await syncScavengeToSupabase(poi: poi, items: items)
        }

        isScavenging = false
        lastScavengeResult = items
        UINotificationFeedbackGenerator().notificationOccurred(.success)
        LogDebug("ğŸ¤– [AIæœåˆ®] åœ¨ã€Œ\(poi.name)ã€è·å¾—ï¼š\(items.map { $0.name }.joined(separator: ", "))")
        return items
    }

    /// åŒæ­¥æœåˆ®ç»“æœåˆ° Supabase
    @MainActor
    private func syncScavengeToSupabase(poi: POIModel, items: [BackpackItem]) async {
        do {
            let session = try await supabaseClient.auth.session
            let userId = session.user.id.uuidString

            struct InventoryRecord: Encodable {
                let user_id: String
                let item_name: String
                let item_rarity: String
                let weight: Double
                let backstory: String?
                let is_ai_generated: Bool
                let source_poi: String
                let created_at: String
            }

            let formatter = ISO8601DateFormatter()
            for item in items {
                let record = InventoryRecord(
                    user_id: userId,
                    item_name: item.name,
                    item_rarity: item.itemRarity?.rawValue ?? "æ™®é€š",
                    weight: item.weight,
                    backstory: item.backstory,
                    is_ai_generated: item.isAIGenerated,
                    source_poi: poi.name,
                    created_at: formatter.string(from: Date())
                )
                try await supabaseClient
                    .from("user_inventory")
                    .insert(record)
                    .execute()
            }
            LogDebug("â˜ï¸ [åŒæ­¥] \(items.count) ä»¶ç‰©å“å·²åŒæ­¥åˆ° user_inventory")
        } catch {
            LogError("âŒ [åŒæ­¥] user_inventory åŒæ­¥å¤±è´¥ï¼š\(error.localizedDescription)")
        }
    }

    // MARK: - ç¨€æœ‰åº¦æ‰è½è¡¨

    /// æ ¹æ® POI ç¨€æœ‰åº¦ç”Ÿæˆæ‰è½ç‰©å“
    private func generateLootByRarity(_ rarity: POIRarity) -> [BackpackItem] {
        // æ‰è½æ± ï¼šæŒ‰ç¨€æœ‰åº¦å†³å®šç‰©å“ç§ç±»å’Œæ•°é‡
        let lootPool: [(itemId: String, name: String, category: ItemCategory, weight: Double, icon: String)]
        let itemCount: Int
        let maxQuantity: Int

        switch rarity {
        case .common:
            itemCount = Int.random(in: 1...2)
            maxQuantity = 2
            lootPool = [
                ("water_001", "çŸ¿æ³‰æ°´", .water, 0.5, "drop.fill"),
                ("food_002", "å‹ç¼©é¥¼å¹²", .food, 0.2, "rectangle.compress.vertical"),
                ("material_004", "å¸ƒæ–™", .material, 0.5, "square.fill"),
            ]
        case .rare:
            itemCount = Int.random(in: 2...3)
            maxQuantity = 3
            lootPool = [
                ("food_001", "ç½å¤´é£Ÿå“", .food, 0.3, "square.stack.3d.up.fill"),
                ("medical_001", "ç»·å¸¦", .medical, 0.05, "cross.case.fill"),
                ("tool_001", "æ‰‹ç”µç­’", .tool, 0.3, "flashlight.on.fill"),
                ("material_001", "æœ¨æ", .material, 1.5, "rectangle.stack.fill"),
            ]
        case .epic:
            itemCount = Int.random(in: 2...3)
            maxQuantity = 4
            lootPool = [
                ("medical_002", "æ­¢ç—›è¯", .medical, 0.02, "pills.fill"),
                ("medical_003", "æŠ—ç”Ÿç´ ", .medical, 0.03, "syringe.fill"),
                ("tool_002", "ç»³å­", .tool, 0.8, "link"),
                ("material_002", "åºŸé‡‘å±", .material, 2.0, "cube.fill"),
                ("material_003", "ç‡ƒæ–™ç½", .material, 2.0, "fuelpump.fill"),
            ]
        case .legendary:
            itemCount = Int.random(in: 3...4)
            maxQuantity = 5
            lootPool = [
                ("medical_003", "æŠ—ç”Ÿç´ ", .medical, 0.03, "syringe.fill"),
                ("material_003", "ç‡ƒæ–™ç½", .material, 2.0, "fuelpump.fill"),
                ("tool_001", "æ‰‹ç”µç­’", .tool, 0.3, "flashlight.on.fill"),
                ("tool_002", "ç»³å­", .tool, 0.8, "link"),
                ("food_001", "ç½å¤´é£Ÿå“", .food, 0.3, "square.stack.3d.up.fill"),
                ("water_001", "çŸ¿æ³‰æ°´", .water, 0.5, "drop.fill"),
            ]
        }

        let qualities: [ItemQuality] = [.poor, .normal, .good, .excellent]

        var result: [BackpackItem] = []
        var usedIds: Set<String> = []
        let count = min(itemCount, lootPool.count)

        for _ in 0..<count {
            // éšæœºé€‰ä¸€ä¸ªæœªç”¨è¿‡çš„ç‰©å“
            let available = lootPool.filter { !usedIds.contains($0.itemId) }
            guard let template = available.randomElement() else { break }
            usedIds.insert(template.itemId)

            let quantity = Int.random(in: 1...maxQuantity)
            let quality = qualities.randomElement()

            result.append(BackpackItem(
                id: UUID().uuidString,
                itemId: template.itemId,
                name: template.name,
                category: template.category,
                quantity: quantity,
                weight: template.weight,
                quality: quality,
                icon: template.icon
            ))
        }

        return result
    }

    // MARK: - æ—§çš„ä¸€é”®åœˆåœ°ï¼ˆä¿ç•™å…¼å®¹ï¼‰

    @MainActor
    func claimTerritory() {
        guard let loc = userLocation else { return }
        let newT = TerritoryModel(
            id: UUID(), lat: loc.coordinate.latitude, lon: loc.coordinate.longitude,
            claimedAt: Date(), name: "å¿«é€Ÿé¢†åœ°", area: 0, pointCount: 1
        )
        self.claimedTerritories.append(newT)
        UINotificationFeedbackGenerator().notificationOccurred(.success)
        LogDebug("ğŸš© [åœˆåœ°] å¿«é€Ÿå é¢† @ (\(String(format: "%.5f", newT.lat)), \(String(format: "%.5f", newT.lon)))")
    }

    // MARK: - æµ‹è¯• POI

    #if DEBUG

    @MainActor
    func createTestPOI() {
        guard let loc = userLocation else { return }
        let rarity = POIRarity.allCases.randomElement()!
        let new = POIModel(
            id: UUID(),
            name: "åºŸå¼ƒè¡¥ç»™ç‚¹ #\(Int.random(in: 10...99))",
            latitude: loc.coordinate.latitude + Double.random(in: -0.0008...0.0008),
            longitude: loc.coordinate.longitude + Double.random(in: -0.0008...0.0008),
            rarity: rarity
        )
        self.nearbyPOIs.append(new)
        LogDebug("ğŸ“ [æµ‹è¯•] ç”Ÿæˆ POIï¼š\(new.name)ï¼ˆ\(rarity.rawValue)ï¼‰")
    }

    @MainActor
    func createMultipleTestPOIs(count: Int = 5) {
        for _ in 0..<count { createTestPOI() }
        LogDebug("ğŸ“ [æµ‹è¯•] æ‰¹é‡ç”Ÿæˆ \(count) ä¸ª POI")
    }

    #endif

}
