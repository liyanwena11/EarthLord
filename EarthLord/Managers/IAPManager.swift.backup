import Foundation
import StoreKit
import SwiftUI

// MARK: - IAPManager

@MainActor
class IAPManager: ObservableObject {
    
    static let shared = IAPManager()
    
    @Published var products: [StoreProduct] = []
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var purchaseInProgress: Bool = false
    
    private var productIdentifiers: Set<String>
    private var updates: Task<Void, Never>? = nil
    
    private init() {
        self.productIdentifiers = Set(IAPProductID.allCases.map { $0.rawValue })
        startProductUpdates()
    }
    
    deinit {
        updates?.cancel()
    }
    
    // MARK: - StoreKit Setup
    
    private func startProductUpdates() {
        updates = Task {
            for await _ in StoreKit.Transaction.updates {
                await loadProducts()
            }
        }
    }
    
    // MARK: - Products
    
    func loadProducts() async {
        isLoading = true
        defer { isLoading = false }

        LogDebug("üì¶ [IAP] ÂºÄÂßãÂä†ËΩΩ‰∫ßÂìÅ...")
        LogDebug("üì¶ [IAP] ‰∫ßÂìÅÊ†áËØÜÁ¨¶: \(productIdentifiers)")

        do {
            let storeProducts = try await StoreKit.Product.products(for: productIdentifiers)

            LogDebug("üì¶ [IAP] StoreKit ËøîÂõû‰∫ßÂìÅÊï∞Èáè: \(storeProducts.count)")

            // ‚úÖ ‰øÆÂ§çÔºöÊ£ÄÊü•ËøîÂõûÁöÑ‰∫ßÂìÅÊòØÂê¶‰∏∫Á©∫
            if storeProducts.isEmpty {
                LogWarning("‚ö†Ô∏è [IAP] StoreKit ËøîÂõûÁ©∫‰∫ßÂìÅÂàóË°®Ôºå‰ΩøÁî®Âç†‰ΩçÂïÜÂìÅ")
                products = createPlaceholderProducts()
                errorMessage = "Ê≠£Âú®ËøûÊé•ÂïÜÂ∫óÔºåÈÉ®ÂàÜÂïÜÂìÅÂèØËÉΩ‰∏çÂèØÁî®"
                return
            }

            // Create SupplyPack models for each product
            var storeKitProducts: [StoreProduct] = []

            for product in storeProducts {
                LogDebug("üì¶ [IAP] ÊâæÂà∞‰∫ßÂìÅ: \(product.displayName), ID: \(product.id)")
                if let supplyPack = createSupplyPack(for: product) {
                    storeKitProducts.append(StoreProduct(product: product, supplyPack: supplyPack))
                    LogDebug("üì¶ [IAP] ÂàõÂª∫Áâ©ËµÑÂåÖ: \(supplyPack.name)")
                } else {
                    storeKitProducts.append(StoreProduct(product: product))
                    LogDebug("üì¶ [IAP] ÂàõÂª∫ÈÄöÁî®‰∫ßÂìÅ: \(product.displayName)")
                }
            }

            products = storeKitProducts
            errorMessage = nil // Ê∏ÖÈô§ÈîôËØØ‰ø°ÊÅØ
            LogInfo("üì¶ [IAP] Âä†ËΩΩ‰∫ßÂìÅÊàêÂäü: \(products.count) ‰∏™")

        } catch {
            // ‚úÖ ‰øÆÂ§çÔºöÊçïËé∑ÈîôËØØÊó∂‰ΩøÁî®Âç†‰ΩçÂïÜÂìÅ
            LogError("‚ùå [IAP] Âä†ËΩΩ‰∫ßÂìÅÂ§±Ë¥•: \(error.localizedDescription)")
            LogWarning("‚ö†Ô∏è [IAP] ‰ΩøÁî®Âç†‰ΩçÂïÜÂìÅÔºåÁ°Æ‰øùÂïÜÂüéÂèØÁî®")

            products = createPlaceholderProducts()
            errorMessage = "ÂïÜÂ∫óËøûÊé•‰∏≠ÔºåÂïÜÂìÅÂèØËÉΩÁ®çÂêéÂèØÁî®"
        }
    }

    // ‚úÖ ‰øÆÂ§çÔºöÂàõÂª∫Âç†‰ΩçÂïÜÂìÅÔºåÁ°Æ‰øùÂïÜÂüéÂßãÁªàÊúâÂÜÖÂÆπÊòæÁ§∫
    private func createPlaceholderProducts() -> [StoreProduct] {
        LogDebug("üì¶ [IAP] ÂàõÂª∫Âç†‰ΩçÂïÜÂìÅ...")

        let placeholderPacks = [
            SupplyPack(
                id: IAPProductID.survivorPack.rawValue,
                name: "ÁîüÂ≠òËÄÖË°•ÁªôÂåÖ",
                description: "Âü∫Á°ÄÁîüÂ≠òÁâ©ËµÑÔºåÈÄÇÂêàÊñ∞ÊâãÂπ∏Â≠òËÄÖ",
                price: "¬•6.00",
                productId: IAPProductID.survivorPack.rawValue,
                rarity: "common",
                items: [
                    PackItem(itemId: "water", quantity: 10, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 2, rarity: "common", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 10, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 2, rarity: "common", guaranteed: true)
                ]
            ),
            SupplyPack(
                id: IAPProductID.explorerPack.rawValue,
                name: "Êé¢Á¥¢ËÄÖÁâ©ËµÑÂåÖ",
                description: "‰∏∞ÂØåÁöÑÊé¢Á¥¢Ë£ÖÂ§áÔºåÂä©‰Ω†ÂºÄÊãìÊñ∞È¢ÜÂú∞",
                price: "¬•18.00",
                productId: IAPProductID.explorerPack.rawValue,
                rarity: "rare",
                items: [
                    PackItem(itemId: "water", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "flashlight", quantity: 1, rarity: "rare", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "flashlight", quantity: 1, rarity: "rare", guaranteed: true)
                ]
            ),
            SupplyPack(
                id: IAPProductID.lordPack.rawValue,
                name: "È¢Ü‰∏ªÁâ©ËµÑÂåÖ",
                description: "È´òÁ∫ßËµÑÊ∫êÂ•óË£ÖÔºåÂª∫Á´ã‰Ω†ÁöÑÊú´Êó•Â∏ùÂõΩ",
                price: "¬•30.00",
                productId: IAPProductID.lordPack.rawValue,
                rarity: "epic",
                items: [
                    PackItem(itemId: "water", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 3, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 20, rarity: "common", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 3, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 20, rarity: "common", guaranteed: true)
                ]
            ),
            SupplyPack(
                id: IAPProductID.overlordPack.rawValue,
                name: "Êú´Êó•Èú∏‰∏ªÂåÖ",
                description: "ÁªàÊûÅÁâ©ËµÑÂåÖÔºåÂåÖÂê´ÊâÄÊúâÁ±ªÂûãÁöÑËµÑÊ∫ê",
                price: "¬•68.00",
                productId: IAPProductID.overlordPack.rawValue,
                rarity: "legendary",
                items: [
                    PackItem(itemId: "water", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 10, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 50, rarity: "common", guaranteed: true),
                    PackItem(itemId: "stone", quantity: 40, rarity: "common", guaranteed: true),
                    PackItem(itemId: "metal", quantity: 30, rarity: "rare", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 10, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 50, rarity: "common", guaranteed: true),
                    PackItem(itemId: "stone", quantity: 40, rarity: "common", guaranteed: true),
                    PackItem(itemId: "metal", quantity: 30, rarity: "rare", guaranteed: true)
                ]
            )
        ]

        // ÂàõÂª∫Âç†‰Ωç StoreProduct
        return placeholderPacks.map { pack in
            StoreProduct(
                product: PlaceholderProduct(id: pack.id, displayName: pack.name, displayPrice: pack.price),
                supplyPack: pack
            )
        }
    }
    
    private func createSupplyPack(for product: Product) -> SupplyPack? {
        guard let productID = IAPProductID(rawValue: product.id) else { return nil }
        
        switch productID {
        case .survivorPack:
            return SupplyPack(
                id: product.id,
                name: "ÁîüÂ≠òËÄÖË°•ÁªôÂåÖ",
                description: "Âü∫Á°ÄÁîüÂ≠òÁâ©ËµÑÔºåÈÄÇÂêàÊñ∞ÊâãÂπ∏Â≠òËÄÖ",
                price: product.displayPrice,
                productId: product.id,
                rarity: "common",
                items: [
                    PackItem(itemId: "water", quantity: 10, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 2, rarity: "common", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 10, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 2, rarity: "common", guaranteed: true)
                ]
            )
        case .explorerPack:
            return SupplyPack(
                id: product.id,
                name: "Êé¢Á¥¢ËÄÖÁâ©ËµÑÂåÖ",
                description: "‰∏∞ÂØåÁöÑÊé¢Á¥¢Ë£ÖÂ§áÔºåÂä©‰Ω†ÂºÄÊãìÊñ∞È¢ÜÂú∞",
                price: product.displayPrice,
                productId: product.id,
                rarity: "rare",
                items: [
                    PackItem(itemId: "water", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "flashlight", quantity: 1, rarity: "rare", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 15, rarity: "common", guaranteed: true),
                    PackItem(itemId: "bandage", quantity: 5, rarity: "common", guaranteed: true),
                    PackItem(itemId: "flashlight", quantity: 1, rarity: "rare", guaranteed: true)
                ]
            )
        case .lordPack:
            return SupplyPack(
                id: product.id,
                name: "È¢Ü‰∏ªÁâ©ËµÑÂåÖ",
                description: "È´òÁ∫ßËµÑÊ∫êÂ•óË£ÖÔºåÂª∫Á´ã‰Ω†ÁöÑÊú´Êó•Â∏ùÂõΩ",
                price: product.displayPrice,
                productId: product.id,
                rarity: "epic",
                items: [
                    PackItem(itemId: "water", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 3, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 20, rarity: "common", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 30, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 3, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 20, rarity: "common", guaranteed: true)
                ]
            )
        case .overlordPack:
            return SupplyPack(
                id: product.id,
                name: "Êú´Êó•Èú∏‰∏ªÂåÖ",
                description: "ÁªàÊûÅÁâ©ËµÑÂåÖÔºåÂåÖÂê´ÊâÄÊúâÁ±ªÂûãÁöÑËµÑÊ∫ê",
                price: product.displayPrice,
                productId: product.id,
                rarity: "legendary",
                items: [
                    PackItem(itemId: "water", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 10, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 50, rarity: "common", guaranteed: true),
                    PackItem(itemId: "stone", quantity: 40, rarity: "common", guaranteed: true),
                    PackItem(itemId: "metal", quantity: 30, rarity: "rare", guaranteed: true)
                ],
                guaranteedItems: [
                    PackItem(itemId: "water", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "canned_food", quantity: 80, rarity: "common", guaranteed: true),
                    PackItem(itemId: "medical_kit", quantity: 10, rarity: "rare", guaranteed: true),
                    PackItem(itemId: "wood", quantity: 50, rarity: "common", guaranteed: true),
                    PackItem(itemId: "stone", quantity: 40, rarity: "common", guaranteed: true),
                    PackItem(itemId: "metal", quantity: 30, rarity: "rare", guaranteed: true)
                ]
            )
        }
    }
    
    // MARK: - Purchases
    
    func purchase(_ product: StoreProduct) async -> PurchaseResult {
        guard !purchaseInProgress else {
            return .failed(IAPError.purchaseFailed)
        }
        
        purchaseInProgress = true
        defer { purchaseInProgress = false }
        
        do {
            let result = try await product.product.purchase()
            
            switch result {
            case .success(let verification):
                switch verification {
                case .verified(let transaction):
                    // Handle successful purchase
                    await handlePurchase(transaction, for: product)
                    await transaction.finish()
                    return .success(product.product)
                case .unverified(_, let error):
                    LogError("‚ùå [IAP] ‰∫§ÊòìÈ™åËØÅÂ§±Ë¥•: \(error)")
                    return .failed(error)
                }
            case .userCancelled:
                return .cancelled
            case .pending:
                return .pending
            default:
                return .failed(IAPError.purchaseFailed)
            }
        } catch {
            LogError("‚ùå [IAP] Ë¥≠‰π∞Â§±Ë¥•: \(error)")
            return .failed(error)
        }
    }
    
    private func handlePurchase(_ transaction: StoreKit.Transaction, for product: StoreProduct) async {
        LogInfo("‚úÖ [IAP] Ë¥≠‰π∞ÊàêÂäü: \(product.displayName)")
        // Add items to mailbox
        if let supplyPack = product.supplyPack {
            let mailboxManager = MailboxManager.shared
            
            do {
                // Combine guaranteed and random items
                var allItems = supplyPack.guaranteedItems
                
                // Add random items if applicable
                let randomItems = supplyPack.items.filter { !$0.guaranteed }
                if !randomItems.isEmpty {
                    // For simplicity, just add all random items for now
                    allItems.append(contentsOf: randomItems)
                }
                
                try await mailboxManager.addItems(allItems, productID: product.id, transactionID: String(transaction.id))
                LogDebug("üì¨ [IAP] Áâ©ËµÑÂ∑≤Ê∑ªÂä†Âà∞ÈÇÆÁÆ±: \(allItems.count) ‰∏™Áâ©ÂìÅ")
            } catch {
                LogError("‚ùå [IAP] Ê∑ªÂä†Âà∞ÈÇÆÁÆ±Â§±Ë¥•: \(error)")
            }
        }
    }
    
    // MARK: - Restore Purchases
    
    func restorePurchases() async -> Bool {
        isLoading = true
        defer { isLoading = false }
        
        do {
            for await result in StoreKit.Transaction.currentEntitlements {
                switch result {
                case .verified(let transaction):
                    // Handle restored purchase
                    LogDebug("üîÑ [IAP] ÊÅ¢Â§çË¥≠‰π∞: \(transaction.productID)")
                    await transaction.finish()
                case .unverified(_, let error):
                    LogError("‚ùå [IAP] ÊÅ¢Â§çË¥≠‰π∞È™åËØÅÂ§±Ë¥•: \(error)")
                }
            }
            return true
        } catch {
            errorMessage = "ÊÅ¢Â§çË¥≠‰π∞Â§±Ë¥•"
            LogError("‚ùå [IAP] ÊÅ¢Â§çË¥≠‰π∞Â§±Ë¥•: \(error)")
            return false
        }
    }
    
    // MARK: - Helpers
    
    func getProduct(for productId: String) -> StoreProduct? {
        return products.first { $0.id == productId }
    }
    
    var hasProducts: Bool {
        !products.isEmpty
    }
}

// MARK: - StoreKit 2 Transaction Observer

class StoreKitTransactionObserver: NSObject, SKPaymentTransactionObserver {
    static let shared = StoreKitTransactionObserver()
    
    private override init() {
        super.init()
        SKPaymentQueue.default().add(self)
    }
    
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        for transaction in transactions {
            switch transaction.transactionState {
            case .purchased:
                LogDebug("üí∞ [StoreKit] Ë¥≠‰π∞ÂÆåÊàê: \(transaction.payment.productIdentifier)")
                queue.finishTransaction(transaction)
            case .restored:
                LogDebug("üîÑ [StoreKit] Ë¥≠‰π∞ÊÅ¢Â§ç: \(transaction.payment.productIdentifier)")
                queue.finishTransaction(transaction)
            case .failed:
                if let error = transaction.error {
                    LogError("‚ùå [StoreKit] Ë¥≠‰π∞Â§±Ë¥•: \(error.localizedDescription)")
                }
                queue.finishTransaction(transaction)
            case .deferred:
                LogDebug("‚è≥ [StoreKit] Ë¥≠‰π∞Âª∂Ëøü")
            case .purchasing:
                LogDebug("üîÑ [StoreKit] Ë¥≠‰π∞‰∏≠")
            @unknown default:
                break
            }
        }
    }
}
